#!/usr/bin/with-contenv bashio

# Ensure unbuffered output
export PYTHONUNBUFFERED=1

# Disable strict mode for unbound variables (allows ${VAR:-default} syntax)
set +u

# Function to log - use only bashio (appears in Protokoll automatically)
log_info() {
    bashio::log.info "$*" 2>/dev/null || echo "[INFO] $*" >&2
}

log_error() {
    bashio::log.error "$*" 2>/dev/null || echo "[ERROR] $*" >&2
}

log_info "=========================================="
log_info "net4home Server Add-on wird gestartet..."
log_info "=========================================="

# Read configuration from Home Assistant
log_info "Lese Konfiguration aus Home Assistant..."
LOG_LEVEL_RAW=$(bashio::config 'loglevel')
# Extract numeric value from loglevel (format: "X - Description")
LOG_LEVEL=$(echo "$LOG_LEVEL_RAW" | cut -d' ' -f1)
log_info "Log Level: $LOG_LEVEL_RAW -> $LOG_LEVEL"
PORT=$(bashio::config 'port')
COMPORT=$(bashio::config 'comport')
NO_PASSWORDS=$(bashio::config 'noPasswords')
IPV6=$(bashio::config 'ipv6')

# Convert noPasswords boolean to int
if [ "$NO_PASSWORDS" = "true" ]; then
    NO_PASSWORDS_INT=1
else
    NO_PASSWORDS_INT=0
fi

# Convert ipv6 boolean to int
if [ "$IPV6" = "true" ]; then
    IPV6_INT=1
else
    IPV6_INT=0
fi

# Create config directory if it doesn't exist
mkdir -p /data
log_info "Konfigurationsverzeichnis erstellt: /data"

# Generate n4hSvc.cfg from Home Assistant config
log_info "Generiere n4hSvc.cfg Konfigurationsdatei..."

# Build password list string from JSON array
# Read passwords from options.json and parse with jq (available in HA add-ons)
PASSWORD_LIST=""
if [ -f /data/options.json ]; then
    PASSWORD_COUNT=$(jq -r '.passwords | length' /data/options.json 2>/dev/null || echo "0")
    if [ "$PASSWORD_COUNT" -gt 0 ] && [ "$PASSWORD_COUNT" != "null" ]; then
        # Use jq to extract passwords and format them
        PASSWORD_LIST=$(jq -r '.passwords[] | "\"" + . + "\""' /data/options.json 2>/dev/null | tr '\n' ',' | sed 's/,$//')
    fi
fi

# Write config file
cat > /data/n4hSvc.cfg <<EOF
# V1.0  07/2011   (c) kk
# Generated by Home Assistant Add-on
#
# loglevel 0    -> normal, nur Fehler
# - - - - ab hier nur zu DebugZwecken! - - - - -
# loglevel >=9  -> +Buspakete
# loglevel >=10 -> +Passwörter IO ! Achtung, u.a. im /var/log/messages

params = {
    loglevel = ${LOG_LEVEL};
    port = ${PORT};
    comport = "${COMPORT}";
    noPasswords = ${NO_PASSWORDS_INT};
    ipv6 = ${IPV6_INT};
};

# Passwörter nur encoded hier eintragen!
# Nur 32 Zeichen hex je Passwort!

passwords = {
    list = [${PASSWORD_LIST}];
};
EOF

log_info "Konfigurationsdatei geschrieben: /data/n4hSvc.cfg"
log_info "=========================================="
log_info "Aktuelle Konfiguration:"
log_info "  Log Level: ${LOG_LEVEL}"
log_info "  Port: ${PORT}"
log_info "  Serial Port: ${COMPORT}"
log_info "  No Passwords: ${NO_PASSWORDS_INT}"
log_info "  IPv6: ${IPV6_INT}"
if [ -n "$PASSWORD_LIST" ]; then
    log_info "  Passwords: ${PASSWORD_COUNT} konfiguriert"
else
    log_info "  Passwords: keine"
fi
log_info "=========================================="

# Display the generated config file in the log
log_info "Generierte Konfigurationsdatei (/data/n4hSvc.cfg):"
log_info "----------------------------------------"
cat /data/n4hSvc.cfg | while IFS= read -r line || [ -n "$line" ]; do
    log_info "  $line"
done
log_info "----------------------------------------"

log_info "Starte net4home Server..."
log_info "Service wird gestartet, alle Ausgaben erscheinen im Protokoll..."
log_info "=========================================="

# Start the service and ensure all output goes to stdout/stderr (appears in Protokoll)
# Assuming n4hSvc reads config from /data/n4hSvc.cfg or current directory
# Adjust the command line arguments as needed for your binary

# Check if binary exists
if [ ! -f /usr/bin/n4hSvc ]; then
    log_error "FEHLER: /usr/bin/n4hSvc nicht gefunden!"
    exit 1
fi

# Check binary properties and diagnose issues
log_info "Prüfe Binary /usr/bin/n4hSvc..."
log_info "Datei existiert: $(test -f /usr/bin/n4hSvc && echo 'JA' || echo 'NEIN')"
log_info "Ausführbar: $(test -x /usr/bin/n4hSvc && echo 'JA' || echo 'NEIN')"
log_info "Dateigröße: $(stat -c%s /usr/bin/n4hSvc 2>/dev/null || stat -f%z /usr/bin/n4hSvc 2>/dev/null || echo 'unbekannt') Bytes"

if command -v file >/dev/null 2>&1; then
    FILE_INFO=$(file /usr/bin/n4hSvc 2>&1)
    log_info "Dateityp: $FILE_INFO"
fi

# Check if the interpreter exists (critical for execution)
INTERPRETER="/lib/ld-linux-aarch64.so.1"
INTERPRETER_ALT="/lib64/ld-linux-aarch64.so.1"

if [ -f "$INTERPRETER" ]; then
    log_info "Interpreter gefunden: $INTERPRETER"
elif [ -f "$INTERPRETER_ALT" ]; then
    log_info "Interpreter gefunden (alternativer Pfad): $INTERPRETER_ALT"
    # Create symlink if needed
    mkdir -p /lib
    ln -sf "$INTERPRETER_ALT" "$INTERPRETER" 2>/dev/null || true
    log_info "Symlink erstellt: $INTERPRETER -> $INTERPRETER_ALT"
else
    log_error "KRITISCH: Interpreter $INTERPRETER nicht gefunden!"
    log_error "Das Binary benötigt diesen Interpreter zum Ausführen."
    # Try to find alternative location
    ALTERNATIVE=$(find /lib /lib64 /usr/lib -name "ld-linux-aarch64.so*" 2>/dev/null | head -n 1)
    if [ -n "$ALTERNATIVE" ]; then
        log_info "Alternativer Interpreter gefunden: $ALTERNATIVE"
        mkdir -p /lib
        ln -sf "$ALTERNATIVE" "$INTERPRETER" 2>/dev/null || true
        log_info "Symlink erstellt: $INTERPRETER -> $ALTERNATIVE"
    else
        log_error "Kein aarch64 Interpreter gefunden - Binary kann nicht ausgeführt werden!"
        log_error "Bitte installieren Sie libc6 oder libc6-compat im Dockerfile."
    fi
fi

# Quick check for libraries using readelf (faster than ldd)
if command -v readelf >/dev/null 2>&1; then
    log_info "Prüfe benötigte Bibliotheken (readelf)..."
    readelf -d /usr/bin/n4hSvc 2>/dev/null | grep -i "needed" | head -n 10 | while IFS= read -r line; do
        log_info "  $line"
    done
fi

# Skip ldd check if it hangs - just verify interpreter exists
# The binary will fail at runtime if libraries are missing anyway
log_info "Bibliotheken werden beim Start automatisch geprüft..."

# Check if it's a script that needs an interpreter (skip for binary)
# This check is mainly for debugging - n4hSvc is a binary, not a script
if [ -f /usr/bin/n4hSvc ]; then
    # Use head with -c to avoid null byte issues
    FIRST_BYTES=$(head -c 2 /usr/bin/n4hSvc 2>/dev/null | od -An -tx1 | tr -d ' \n')
    # Check for ELF magic number (7f 45 4c 46) or shebang (23 21)
    if [ "$FIRST_BYTES" = "7f45" ] || [ "$FIRST_BYTES" = "454c" ]; then
        log_info "Binary erkannt (ELF Format)"
    elif [ "$FIRST_BYTES" = "2321" ]; then
        FIRST_LINE=$(head -n 1 /usr/bin/n4hSvc 2>/dev/null | tr -d '\0')
        if echo "$FIRST_LINE" | grep -q "^#!"; then
            INTERPRETER=$(echo "$FIRST_LINE" | sed 's/^#!//' | awk '{print $1}')
            log_info "Script erkannt, benötigt Interpreter: $INTERPRETER"
            if [ ! -f "$INTERPRETER" ]; then
                log_error "FEHLER: Interpreter $INTERPRETER nicht gefunden!"
            fi
        fi
    fi
fi

# Final check: verify interpreter exists before starting
if [ ! -f "$INTERPRETER" ] && [ ! -f "$INTERPRETER_ALT" ]; then
    log_error "FEHLER: Interpreter $INTERPRETER fehlt - Binary kann nicht ausgeführt werden!"
    log_error "Bitte stellen Sie sicher, dass libc6 installiert ist."
    exit 1
fi

# Check for required libraries and create symlinks if needed
log_info "Prüfe benötigte Bibliotheken..."
log_info "Suche nach libconfig.so..."
for search_path in /usr/lib /lib /usr/lib64 /lib64; do
    if [ -d "$search_path" ]; then
        find "$search_path" -name "libconfig.so*" 2>/dev/null | head -3 | while IFS= read -r lib; do
            log_info "  Gefunden: $lib"
        done || true
    fi
done

log_info "Suche nach libblkid.so..."
for search_path in /usr/lib /lib /usr/lib64 /lib64; do
    if [ -d "$search_path" ]; then
        find "$search_path" -name "libblkid.so*" 2>/dev/null | head -3 | while IFS= read -r lib; do
            log_info "  Gefunden: $lib"
        done || true
    fi
done

LIB_CONFIG_FOUND=$(find /usr/lib /lib /usr/lib64 /lib64 -name "libconfig.so*" 2>/dev/null | head -1) || true
LIB_BLKID_FOUND=$(find /usr/lib /lib /usr/lib64 /lib64 -name "libblkid.so*" 2>/dev/null | head -1) || true

# Common library paths for aarch64
LIB_PATHS="/usr/lib/aarch64-linux-gnu /lib/aarch64-linux-gnu /usr/lib /lib /usr/lib64 /lib64"

if [ -z "$LIB_CONFIG_FOUND" ]; then
    log_error "FEHLT: libconfig.so nicht gefunden!"
    log_error "Versuche manuelle Installation..."
    # Try to install at runtime (if possible)
    if [ -f /etc/alpine-release ]; then
        log_info "Alpine erkannt - versuche libconfig zu installieren..."
        apk add --no-cache libconfig libconfig-dev 2>&1 || true
        log_info "libconfig Installation abgeschlossen"
    elif [ -f /etc/debian_version ]; then
        log_info "Debian erkannt - versuche libconfig9 zu installieren..."
        apt-get update && apt-get install -y --no-install-recommends libconfig9 2>&1 || true
        log_info "libconfig9 Installation abgeschlossen"
    fi
    # Re-search for library after installation
    log_info "Suche erneut nach libconfig.so..."
    LIB_CONFIG_FOUND=$(find /usr/lib /lib /usr/lib64 /lib64 -name "libconfig.so*" 2>/dev/null | head -1) || true
    if [ -z "$LIB_CONFIG_FOUND" ]; then
        log_error "libconfig.so konnte nicht gefunden werden nach Installation!"
    else
        log_info "libconfig.so gefunden nach Installation: $LIB_CONFIG_FOUND"
    fi
fi

log_info "Weiter mit libblkid..."

if [ -n "$LIB_CONFIG_FOUND" ]; then
    log_info "libconfig gefunden: $LIB_CONFIG_FOUND"
    # Create symlinks in all common paths
    for lib_path in $LIB_PATHS; do
        if [ ! -f "$lib_path/libconfig.so.9" ]; then
            mkdir -p "$lib_path" 2>/dev/null || true
            ln -sf "$LIB_CONFIG_FOUND" "$lib_path/libconfig.so.9" 2>/dev/null && \
            log_info "Symlink erstellt: $lib_path/libconfig.so.9 -> $LIB_CONFIG_FOUND" && break || true
        else
            log_info "libconfig.so.9 bereits vorhanden: $lib_path/libconfig.so.9"
            break
        fi
    done
fi

if [ -z "$LIB_BLKID_FOUND" ]; then
    log_error "FEHLT: libblkid.so nicht gefunden!"
    log_error "Versuche manuelle Installation..."
    # Try to install at runtime (if possible)
    if [ -f /etc/alpine-release ]; then
        log_info "Alpine erkannt - versuche libblkid zu installieren..."
        # Try different package names that might contain libblkid
        apk add --no-cache libblkid 2>&1 || \
        apk add --no-cache util-linux 2>&1 || \
        apk add --no-cache util-linux-dev 2>&1 || \
        apk add --no-cache blkid 2>&1 || true
        log_info "libblkid Installation abgeschlossen"
    elif [ -f /etc/debian_version ]; then
        log_info "Debian erkannt - versuche libblkid1 zu installieren..."
        apt-get update && apt-get install -y --no-install-recommends libblkid1 util-linux 2>&1 || true
        log_info "libblkid1 Installation abgeschlossen"
    fi
    # Re-search for library after installation
    log_info "Suche erneut nach libblkid.so..."
    LIB_BLKID_FOUND=$(find /usr/lib /lib /usr/lib64 /lib64 -name "libblkid.so*" 2>/dev/null | head -1) || true
    if [ -z "$LIB_BLKID_FOUND" ]; then
        log_error "libblkid.so konnte nicht gefunden werden nach Installation!"
    else
        log_info "libblkid.so gefunden nach Installation: $LIB_BLKID_FOUND"
    fi
fi

log_info "Bibliotheken-Prüfung abgeschlossen"

if [ -n "$LIB_BLKID_FOUND" ]; then
    log_info "libblkid gefunden: $LIB_BLKID_FOUND"
    # Create symlinks in all common paths
    for lib_path in $LIB_PATHS; do
        if [ ! -f "$lib_path/libblkid.so.1" ]; then
            mkdir -p "$lib_path" 2>/dev/null || true
            ln -sf "$LIB_BLKID_FOUND" "$lib_path/libblkid.so.1" 2>/dev/null && \
            log_info "Symlink erstellt: $lib_path/libblkid.so.1 -> $LIB_BLKID_FOUND" && break || true
        else
            log_info "libblkid.so.1 bereits vorhanden: $lib_path/libblkid.so.1"
            break
        fi
    done
fi

# Set LD_LIBRARY_PATH to help find libraries
if [ -z "${LD_LIBRARY_PATH:-}" ]; then
    export LD_LIBRARY_PATH="/usr/lib/aarch64-linux-gnu:/lib/aarch64-linux-gnu:/usr/lib:/lib:/usr/lib64:/lib64"
else
    export LD_LIBRARY_PATH="/usr/lib/aarch64-linux-gnu:/lib/aarch64-linux-gnu:/usr/lib:/lib:/usr/lib64:/lib64:${LD_LIBRARY_PATH}"
fi
log_info "LD_LIBRARY_PATH gesetzt: $LD_LIBRARY_PATH"

# Copy config to expected location (might need to be in current directory or specific path)
cp /data/n4hSvc.cfg /n4hSvc.cfg 2>/dev/null || true
cp /data/n4hSvc.cfg /etc/n4hSvc.cfg 2>/dev/null || true

log_info "Konfigurationsdatei kopiert nach: /n4hSvc.cfg und /etc/n4hSvc.cfg"

# ==========================================
# SERIELLE SCHNITTSTELLEN ERKENNUNG
# ==========================================
log_info "=========================================="
log_info "VERFÜGBARE SERIELLE SCHNITTSTELLEN"
log_info "=========================================="

# Function to get device info
get_device_info() {
    local device=$1
    local info=""
    
    # Try to get USB device info
    if [ -d "/sys/class/tty/$(basename "$device")/device" ]; then
        local sys_path="/sys/class/tty/$(basename "$device")/device"
        
        # Get vendor and product info
        if [ -f "$sys_path/../idVendor" ]; then
            local vendor=$(cat "$sys_path/../idVendor" 2>/dev/null)
            local product=$(cat "$sys_path/../idProduct" 2>/dev/null)
            local manufacturer=$(cat "$sys_path/../manufacturer" 2>/dev/null)
            local product_name=$(cat "$sys_path/../product" 2>/dev/null)
            
            if [ -n "$manufacturer" ] || [ -n "$product_name" ]; then
                info="$manufacturer $product_name"
            elif [ -n "$vendor" ] && [ -n "$product" ]; then
                info="VID:$vendor PID:$product"
            fi
        fi
    fi
    
    echo "$info"
}

# List USB serial devices
log_info ""
log_info "USB Serielle Geräte:"
log_info "-------------------"
USB_DEVICES_FOUND=0
for device in /dev/ttyUSB* /dev/ttyACM*; do
    if [ -e "$device" ]; then
        USB_DEVICES_FOUND=1
        device_info=$(get_device_info "$device")
        if [ -n "$device_info" ]; then
            log_info "  $device - $device_info"
        else
            log_info "  $device"
        fi
    fi
done 2>/dev/null
if [ "$USB_DEVICES_FOUND" -eq 0 ]; then
    log_info "  (keine USB-Geräte gefunden)"
fi

# List built-in serial devices
log_info ""
log_info "Eingebaute Serielle Geräte:"
log_info "---------------------------"
BUILTIN_FOUND=0
for device in /dev/ttyAMA* /dev/ttyS0 /dev/ttyS1; do
    if [ -e "$device" ]; then
        BUILTIN_FOUND=1
        log_info "  $device"
    fi
done 2>/dev/null
if [ "$BUILTIN_FOUND" -eq 0 ]; then
    log_info "  (keine eingebauten Geräte gefunden)"
fi

# List devices by ID (most reliable for configuration)
log_info ""
log_info "Geräte nach ID (empfohlen für Konfiguration):"
log_info "----------------------------------------------"
if [ -d "/dev/serial/by-id" ]; then
    BY_ID_FOUND=0
    for device in /dev/serial/by-id/*; do
        if [ -e "$device" ]; then
            BY_ID_FOUND=1
            target=$(readlink -f "$device" 2>/dev/null)
            device_name=$(basename "$device")
            log_info "  $device"
            log_info "    -> $target"
        fi
    done 2>/dev/null
    if [ "$BY_ID_FOUND" -eq 0 ]; then
        log_info "  (keine Geräte gefunden)"
    fi
else
    log_info "  /dev/serial/by-id/ existiert nicht"
fi

# List devices by path
log_info ""
log_info "Geräte nach Pfad:"
log_info "-----------------"
if [ -d "/dev/serial/by-path" ]; then
    BY_PATH_FOUND=0
    for device in /dev/serial/by-path/*; do
        if [ -e "$device" ]; then
            BY_PATH_FOUND=1
            target=$(readlink -f "$device" 2>/dev/null)
            log_info "  $device"
            log_info "    -> $target"
        fi
    done 2>/dev/null
    if [ "$BY_PATH_FOUND" -eq 0 ]; then
        log_info "  (keine Geräte gefunden)"
    fi
else
    log_info "  /dev/serial/by-path/ existiert nicht"
fi

# Show configured port status
log_info ""
log_info "=========================================="
log_info "KONFIGURIERTER PORT: $COMPORT"
log_info "=========================================="

if [ -e "$COMPORT" ]; then
    log_info "Status: VORHANDEN"
    ls -la "$COMPORT" 2>&1 | while IFS= read -r line; do
        log_info "  $line"
    done
    
    # Show device info if available
    device_info=$(get_device_info "$COMPORT")
    if [ -n "$device_info" ]; then
        log_info "  Gerät: $device_info"
    fi
else
    log_error "Status: NICHT GEFUNDEN!"
    log_error ""
    log_error "Bitte konfigurieren Sie einen der oben aufgelisteten Ports"
    log_error "in der Add-on Konfiguration unter 'comport'."
fi

log_info ""
log_info "Aktuelle Benutzer-ID:"
id 2>&1 | while IFS= read -r line; do
    log_info "  $line"
done || true

# Try to fix permissions on the serial device
if [ -e "$COMPORT" ]; then
    log_info "Versuche Berechtigungen für $COMPORT zu setzen..."
    chmod 666 "$COMPORT" 2>&1 && log_info "chmod 666 erfolgreich" || log_info "chmod fehlgeschlagen (read-only filesystem)"
    
    # Try adding user to audio group (device owner group)
    addgroup root audio 2>/dev/null || true
    
    # Show new permissions
    log_info "Aktuelle Berechtigungen:"
    ls -la "$COMPORT" 2>&1 | while IFS= read -r line; do
        log_info "  $line"
    done
    
    # Try to test read access
    log_info "Teste Lesezugriff auf $COMPORT..."
    if timeout 1 cat "$COMPORT" > /dev/null 2>&1; then
        log_info "Lesezugriff möglich"
    else
        log_info "Lesezugriff-Test beendet (normal bei seriellen Ports)"
    fi
    
    # Try to test write access
    log_info "Teste Schreibzugriff auf $COMPORT..."
    if echo -n "" > "$COMPORT" 2>&1; then
        log_info "Schreibzugriff möglich"
    else
        log_error "Schreibzugriff NICHT möglich!"
    fi
    
    # Try to open with stty to configure
    log_info "Konfiguriere seriellen Port mit stty..."
    if stty -F "$COMPORT" 9600 cs8 -cstopb -parenb 2>&1; then
        log_info "stty Konfiguration erfolgreich"
    else
        log_error "stty Konfiguration fehlgeschlagen"
    fi
fi

log_info "=========================================="
log_info "Führe aus: /usr/bin/n4hSvc /data/n4hSvc.cfg"
log_info "=========================================="

# Change to data directory where config file is
cd /data

# Start service - the binary expects the config file path as first argument (not with -c flag)
exec /usr/bin/n4hSvc /data/n4hSvc.cfg 2>&1 || {
    EXIT_CODE=$?
    log_error "Fehler beim Start mit Pfad-Argument (Exit: $EXIT_CODE), versuche mit n4hSvc.cfg..."
    exec /usr/bin/n4hSvc n4hSvc.cfg 2>&1 || {
        EXIT_CODE=$?
        log_error "Fehler beim Start mit relativem Pfad (Exit: $EXIT_CODE), versuche ohne Argumente..."
        exec /usr/bin/n4hSvc 2>&1 || {
            EXIT_CODE=$?
            log_error "Alle Startversuche fehlgeschlagen (Exit: $EXIT_CODE)"
            exit $EXIT_CODE
        }
    }
}
