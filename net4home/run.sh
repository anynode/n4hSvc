#!/usr/bin/with-contenv bashio

# Ensure unbuffered output
export PYTHONUNBUFFERED=1

# Disable strict mode for unbound variables (allows ${VAR:-default} syntax)
set +u

# Function to log - use only bashio (appears in Protokoll automatically)
log_info() {
    bashio::log.info "$*" 2>/dev/null || echo "[INFO] $*" >&2
}

log_error() {
    bashio::log.error "$*" 2>/dev/null || echo "[ERROR] $*" >&2
}

log_info "=========================================="
log_info "net4home Server Add-on wird gestartet..."
log_info "=========================================="

# Read configuration from Home Assistant
log_info "Lese Konfiguration aus Home Assistant..."
LOG_LEVEL=$(bashio::config 'loglevel')
log_info "Log Level: $LOG_LEVEL"
PORT=$(bashio::config 'port')
COMPORT=$(bashio::config 'comport')
IPV6=$(bashio::config 'ipv6')
ENABLE_HSTIME=$(bashio::config 'enableHSTime')
ENABLE_HS_PACKET_ROUTER=$(bashio::config 'enableHSPacketRouter')

# noPasswords is always set to 1 (password logging disabled)
NO_PASSWORDS_INT=1

# Convert ipv6 boolean to int (inverted: switch ON = ipv6 enabled)
if [ "$IPV6" = "true" ]; then
    IPV6_INT=0
else
    IPV6_INT=1
fi

# Create config directory if it doesn't exist
mkdir -p /data
log_info "Konfigurationsverzeichnis erstellt: /data"

# Generate n4hSvc.cfg from Home Assistant config
log_info "Generiere n4hSvc.cfg Konfigurationsdatei..."

# Passwords list is always empty (no password configuration)
PASSWORD_LIST=""

# Write config file
cat > /data/n4hSvc.cfg <<EOF
# V1.0  012026 (c) ok
# Generated by Home Assistant Add-on
#

params = {
    loglevel = ${LOG_LEVEL};
    port = ${PORT};
    comport = "${COMPORT}";
    noPasswords = 1;
    ipv6 = ${IPV6_INT};
};

# Passwörter nur encoded hier eintragen!
# Nur 32 Zeichen hex je Passwort!

passwords = {
    list = [];
};
EOF

log_info "Konfigurationsdatei geschrieben: /data/n4hSvc.cfg"
log_info "=========================================="
log_info "Log Level: ${LOG_LEVEL}"
log_info "Port: ${PORT}"
log_info "Serial Port: ${COMPORT}"
log_info "IPv6: ${IPV6_INT}"
log_info "=========================================="

# Display the generated config file in the log
cat /data/n4hSvc.cfg | while IFS= read -r line || [ -n "$line" ]; do
    log_info "  $line"
done

log_info "Starte net4home Server..."
log_info "=========================================="

# Start the service and ensure all output goes to stdout/stderr (appears in Protokoll)
# Assuming n4hSvc reads config from /data/n4hSvc.cfg or current directory
# Adjust the command line arguments as needed for your binary

# Check if binary exists
if [ ! -f /usr/bin/n4hSvc ]; then
    log_error "FEHLER: /usr/bin/n4hSvc nicht gefunden!"
    exit 1
fi

# Check binary properties and diagnose issues
log_info "Prüfe Binary /usr/bin/n4hSvc..."
log_info "Datei existiert: $(test -f /usr/bin/n4hSvc && echo 'JA' || echo 'NEIN')"
log_info "Ausführbar: $(test -x /usr/bin/n4hSvc && echo 'JA' || echo 'NEIN')"
log_info "Dateigröße: $(stat -c%s /usr/bin/n4hSvc 2>/dev/null || stat -f%z /usr/bin/n4hSvc 2>/dev/null || echo 'unbekannt') Bytes"

if command -v file >/dev/null 2>&1; then
    FILE_INFO=$(file /usr/bin/n4hSvc 2>&1)
    log_info "Dateityp: $FILE_INFO"
fi

# Check if the interpreter exists (critical for execution)
INTERPRETER="/lib/ld-linux-aarch64.so.1"
INTERPRETER_ALT="/lib64/ld-linux-aarch64.so.1"

if [ -f "$INTERPRETER" ]; then
    log_info "Interpreter gefunden: $INTERPRETER"
elif [ -f "$INTERPRETER_ALT" ]; then
    log_info "Interpreter gefunden (alternativer Pfad): $INTERPRETER_ALT"
    # Create symlink if needed
    mkdir -p /lib
    ln -sf "$INTERPRETER_ALT" "$INTERPRETER" 2>/dev/null || true
    log_info "Symlink erstellt: $INTERPRETER -> $INTERPRETER_ALT"
else
    log_error "KRITISCH: Interpreter $INTERPRETER nicht gefunden!"
    log_error "Das Binary benötigt diesen Interpreter zum Ausführen."
    # Try to find alternative location
    ALTERNATIVE=$(find /lib /lib64 /usr/lib -name "ld-linux-aarch64.so*" 2>/dev/null | head -n 1)
    if [ -n "$ALTERNATIVE" ]; then
        log_info "Alternativer Interpreter gefunden: $ALTERNATIVE"
        mkdir -p /lib
        ln -sf "$ALTERNATIVE" "$INTERPRETER" 2>/dev/null || true
        log_info "Symlink erstellt: $INTERPRETER -> $ALTERNATIVE"
    else
        log_error "Kein aarch64 Interpreter gefunden - Binary kann nicht ausgeführt werden!"
        log_error "Bitte installieren Sie libc6 oder libc6-compat im Dockerfile."
    fi
fi

# Quick check for libraries using readelf (faster than ldd)
if command -v readelf >/dev/null 2>&1; then
    log_info "Prüfe benötigte Bibliotheken (readelf)..."
    readelf -d /usr/bin/n4hSvc 2>/dev/null | grep -i "needed" | head -n 10 | while IFS= read -r line; do
        log_info "  $line"
    done
fi

# Skip ldd check if it hangs - just verify interpreter exists
# The binary will fail at runtime if libraries are missing anyway
log_info "Bibliotheken werden beim Start automatisch geprüft..."

# Check if it's a script that needs an interpreter (skip for binary)
# This check is mainly for debugging - n4hSvc is a binary, not a script
if [ -f /usr/bin/n4hSvc ]; then
    # Use head with -c to avoid null byte issues
    FIRST_BYTES=$(head -c 2 /usr/bin/n4hSvc 2>/dev/null | od -An -tx1 | tr -d ' \n')
    # Check for ELF magic number (7f 45 4c 46) or shebang (23 21)
    if [ "$FIRST_BYTES" = "7f45" ] || [ "$FIRST_BYTES" = "454c" ]; then
        log_info "Binary erkannt (ELF Format)"
    elif [ "$FIRST_BYTES" = "2321" ]; then
        FIRST_LINE=$(head -n 1 /usr/bin/n4hSvc 2>/dev/null | tr -d '\0')
        if echo "$FIRST_LINE" | grep -q "^#!"; then
            INTERPRETER=$(echo "$FIRST_LINE" | sed 's/^#!//' | awk '{print $1}')
            log_info "Script erkannt, benötigt Interpreter: $INTERPRETER"
            if [ ! -f "$INTERPRETER" ]; then
                log_error "FEHLER: Interpreter $INTERPRETER nicht gefunden!"
            fi
        fi
    fi
fi

# Final check: verify interpreter exists before starting
if [ ! -f "$INTERPRETER" ] && [ ! -f "$INTERPRETER_ALT" ]; then
    log_error "FEHLER: Interpreter $INTERPRETER fehlt - Binary kann nicht ausgeführt werden!"
    log_error "Bitte stellen Sie sicher, dass libc6 installiert ist."
    exit 1
fi

# Check for required libraries and create symlinks if needed
# Search in all possible library paths including architecture-specific directories
log_info "Suche nach benoetigten Bibliotheken..."
LIB_CONFIG_FOUND=$(find /usr/lib* /lib* -name "libconfig.so*" 2>/dev/null | head -1) || true
LIB_BLKID_FOUND=$(find /usr/lib* /lib* -name "libblkid.so*" 2>/dev/null | head -1) || true

# Log found libraries
if [ -n "$LIB_CONFIG_FOUND" ]; then
    log_info "libconfig.so gefunden: $LIB_CONFIG_FOUND"
else
    log_info "libconfig.so nicht gefunden, suche weiter..."
fi

if [ -n "$LIB_BLKID_FOUND" ]; then
    log_info "libblkid.so gefunden: $LIB_BLKID_FOUND"
else
    log_info "libblkid.so nicht gefunden, suche weiter..."
fi

# Common library paths for different architectures
LIB_PATHS="/usr/lib/aarch64-linux-gnu /lib/aarch64-linux-gnu /usr/lib/arm-linux-gnueabihf /lib/arm-linux-gnueabihf /usr/lib/x86_64-linux-gnu /lib/x86_64-linux-gnu /usr/lib /lib /usr/lib64 /lib64"

if [ -z "$LIB_CONFIG_FOUND" ]; then
    log_error "FEHLT: libconfig.so nicht gefunden! Versuche Installation..."
    if [ -f /etc/alpine-release ]; then
        log_info "Installiere libconfig fuer Alpine..."
        apk add --no-cache libconfig libconfig-dev 2>&1 | while IFS= read -r line || [ -n "$line" ]; do
            log_info "  $line"
        done || true
    elif [ -f /etc/debian_version ]; then
        log_info "Installiere libconfig9 fuer Debian..."
        apt-get update 2>&1 | while IFS= read -r line || [ -n "$line" ]; do
            log_info "  $line"
        done || true
        apt-get install -y --no-install-recommends libconfig9 2>&1 | while IFS= read -r line || [ -n "$line" ]; do
            log_info "  $line"
        done || true
    fi
    LIB_CONFIG_FOUND=$(find /usr/lib* /lib* -name "libconfig.so*" 2>/dev/null | head -1) || true
    if [ -n "$LIB_CONFIG_FOUND" ]; then
        log_info "libconfig.so nach Installation gefunden: $LIB_CONFIG_FOUND"
    else
        log_error "libconfig.so konnte auch nach Installation nicht gefunden werden!"
        log_error "Verfuegbare libconfig Dateien:"
        find /usr/lib* /lib* -name "*config*" 2>/dev/null | head -10 | while IFS= read -r line || [ -n "$line" ]; do
            log_error "  $line"
        done
    fi
fi

if [ -n "$LIB_CONFIG_FOUND" ]; then
    log_info "Erstelle Symlinks fuer libconfig.so..."
    for lib_path in $LIB_PATHS; do
        if [ ! -f "$lib_path/libconfig.so.9" ] && [ ! -f "$lib_path/libconfig.so" ]; then
            mkdir -p "$lib_path" 2>/dev/null || true
            if ln -sf "$LIB_CONFIG_FOUND" "$lib_path/libconfig.so.9" 2>/dev/null; then
                log_info "  Symlink erstellt: $lib_path/libconfig.so.9 -> $LIB_CONFIG_FOUND"
                break
            fi
        else
            log_info "  $lib_path/libconfig.so.9 existiert bereits"
            break
        fi
    done
else
    log_error "Kann keine Symlinks fuer libconfig.so erstellen - Bibliothek nicht gefunden!"
fi

if [ -z "$LIB_BLKID_FOUND" ]; then
    log_error "FEHLT: libblkid.so nicht gefunden! Versuche Installation..."
    if [ -f /etc/alpine-release ]; then
        log_info "Installiere libblkid fuer Alpine..."
        apk add --no-cache libblkid 2>&1 | while IFS= read -r line || [ -n "$line" ]; do
            log_info "  $line"
        done || \
        apk add --no-cache util-linux 2>&1 | while IFS= read -r line || [ -n "$line" ]; do
            log_info "  $line"
        done || \
        apk add --no-cache util-linux-dev 2>&1 | while IFS= read -r line || [ -n "$line" ]; do
            log_info "  $line"
        done || \
        apk add --no-cache blkid 2>&1 | while IFS= read -r line || [ -n "$line" ]; do
            log_info "  $line"
        done || true
    elif [ -f /etc/debian_version ]; then
        log_info "Installiere libblkid1 fuer Debian..."
        apt-get update 2>&1 | while IFS= read -r line || [ -n "$line" ]; do
            log_info "  $line"
        done || true
        apt-get install -y --no-install-recommends libblkid1 util-linux 2>&1 | while IFS= read -r line || [ -n "$line" ]; do
            log_info "  $line"
        done || true
    fi
    LIB_BLKID_FOUND=$(find /usr/lib* /lib* -name "libblkid.so*" 2>/dev/null | head -1) || true
    if [ -n "$LIB_BLKID_FOUND" ]; then
        log_info "libblkid.so nach Installation gefunden: $LIB_BLKID_FOUND"
    else
        log_error "libblkid.so konnte auch nach Installation nicht gefunden werden!"
        log_error "Verfuegbare libblkid Dateien:"
        find /usr/lib* /lib* -name "*blkid*" 2>/dev/null | head -10 | while IFS= read -r line || [ -n "$line" ]; do
            log_error "  $line"
        done
    fi
fi

if [ -n "$LIB_BLKID_FOUND" ]; then
    log_info "Erstelle Symlinks fuer libblkid.so..."
    for lib_path in $LIB_PATHS; do
        if [ ! -f "$lib_path/libblkid.so.1" ] && [ ! -f "$lib_path/libblkid.so" ]; then
            mkdir -p "$lib_path" 2>/dev/null || true
            if ln -sf "$LIB_BLKID_FOUND" "$lib_path/libblkid.so.1" 2>/dev/null; then
                log_info "  Symlink erstellt: $lib_path/libblkid.so.1 -> $LIB_BLKID_FOUND"
                break
            fi
        else
            log_info "  $lib_path/libblkid.so.1 existiert bereits"
            break
        fi
    done
else
    log_error "Kann keine Symlinks fuer libblkid.so erstellen - Bibliothek nicht gefunden!"
fi

# Set LD_LIBRARY_PATH to help find libraries
if [ -z "${LD_LIBRARY_PATH:-}" ]; then
    export LD_LIBRARY_PATH="/usr/lib/aarch64-linux-gnu:/lib/aarch64-linux-gnu:/usr/lib:/lib:/usr/lib64:/lib64"
else
    export LD_LIBRARY_PATH="/usr/lib/aarch64-linux-gnu:/lib/aarch64-linux-gnu:/usr/lib:/lib:/usr/lib64:/lib64:${LD_LIBRARY_PATH}"
fi

# Copy config to expected location
cp /data/n4hSvc.cfg /n4hSvc.cfg 2>/dev/null || true
cp /data/n4hSvc.cfg /etc/n4hSvc.cfg 2>/dev/null || true

# ==========================================
# SERIELLE SCHNITTSTELLEN ERKENNUNG
# ==========================================
log_info "=========================================="
log_info "VERFÜGBARE SERIELLE SCHNITTSTELLEN"
log_info "=========================================="

# Function to get device info
get_device_info() {
    local device=$1
    local info=""
    
    # Try to get USB device info
    if [ -d "/sys/class/tty/$(basename "$device")/device" ]; then
        local sys_path="/sys/class/tty/$(basename "$device")/device"
        
        # Get vendor and product info
        if [ -f "$sys_path/../idVendor" ]; then
            local vendor=$(cat "$sys_path/../idVendor" 2>/dev/null)
            local product=$(cat "$sys_path/../idProduct" 2>/dev/null)
            local manufacturer=$(cat "$sys_path/../manufacturer" 2>/dev/null)
            local product_name=$(cat "$sys_path/../product" 2>/dev/null)
            
            if [ -n "$manufacturer" ] || [ -n "$product_name" ]; then
                info="$manufacturer $product_name"
            elif [ -n "$vendor" ] && [ -n "$product" ]; then
                info="VID:$vendor PID:$product"
            fi
        fi
    fi
    
    echo "$info"
}

# List USB serial devices
log_info ""
log_info "USB Serielle Geräte:"
log_info "-------------------"
USB_DEVICES_FOUND=0
for device in /dev/ttyUSB* /dev/ttyACM*; do
    if [ -e "$device" ]; then
        USB_DEVICES_FOUND=1
        device_info=$(get_device_info "$device")
        if [ -n "$device_info" ]; then
            log_info "  $device - $device_info"
        else
            log_info "  $device"
        fi
    fi
done 2>/dev/null
if [ "$USB_DEVICES_FOUND" -eq 0 ]; then
    log_info "  (keine USB-Geräte gefunden)"
fi

# List built-in serial devices
log_info ""
log_info "Eingebaute Serielle Geräte:"
log_info "---------------------------"
BUILTIN_FOUND=0
for device in /dev/ttyAMA* /dev/ttyS0 /dev/ttyS1; do
    if [ -e "$device" ]; then
        BUILTIN_FOUND=1
        log_info "  $device"
    fi
done 2>/dev/null
if [ "$BUILTIN_FOUND" -eq 0 ]; then
    log_info "  (keine eingebauten Geräte gefunden)"
fi

# List devices by ID (most reliable for configuration)
log_info ""
log_info "Geräte nach ID (empfohlen für Konfiguration):"
log_info "----------------------------------------------"
if [ -d "/dev/serial/by-id" ]; then
    BY_ID_FOUND=0
    for device in /dev/serial/by-id/*; do
        if [ -e "$device" ]; then
            BY_ID_FOUND=1
            target=$(readlink -f "$device" 2>/dev/null)
            device_name=$(basename "$device")
            log_info "  $device"
            log_info "    -> $target"
        fi
    done 2>/dev/null
    if [ "$BY_ID_FOUND" -eq 0 ]; then
        log_info "  (keine Geräte gefunden)"
    fi
else
    log_info "  /dev/serial/by-id/ existiert nicht"
fi

# List devices by path
log_info ""
log_info "Geräte nach Pfad:"
log_info "-----------------"
if [ -d "/dev/serial/by-path" ]; then
    BY_PATH_FOUND=0
    for device in /dev/serial/by-path/*; do
        if [ -e "$device" ]; then
            BY_PATH_FOUND=1
            target=$(readlink -f "$device" 2>/dev/null)
            log_info "  $device"
            log_info "    -> $target"
        fi
    done 2>/dev/null
    if [ "$BY_PATH_FOUND" -eq 0 ]; then
        log_info "  (keine Geräte gefunden)"
    fi
else
    log_info "  /dev/serial/by-path/ existiert nicht"
fi

# Show configured port status
log_info ""
log_info "=========================================="
log_info "KONFIGURIERTER PORT: $COMPORT"
log_info "=========================================="

if [ -e "$COMPORT" ]; then
    log_info "Status: VORHANDEN"
    ls -la "$COMPORT" 2>&1 | while IFS= read -r line; do
        log_info "  $line"
    done
    
    # Show device info if available
    device_info=$(get_device_info "$COMPORT")
    if [ -n "$device_info" ]; then
        log_info "  Gerät: $device_info"
    fi
else
    log_error "Status: NICHT GEFUNDEN!"
    log_error ""
    log_error "Bitte konfigurieren Sie einen der oben aufgelisteten Ports"
    log_error "in der Add-on Konfiguration unter 'comport'."
fi

log_info ""
log_info "Aktuelle Benutzer-ID:"
id 2>&1 | while IFS= read -r line; do
    log_info "  $line"
done || true

# Try to fix permissions on the serial device
if [ -e "$COMPORT" ]; then
    log_info "Versuche Berechtigungen für $COMPORT zu setzen..."
    chmod 666 "$COMPORT" 2>&1 && log_info "chmod 666 erfolgreich" || log_info "chmod fehlgeschlagen (read-only filesystem)"
    
    # Try adding user to audio group (device owner group)
    addgroup root audio 2>/dev/null || true
    
    # Show new permissions
    log_info "Aktuelle Berechtigungen:"
    ls -la "$COMPORT" 2>&1 | while IFS= read -r line; do
        log_info "  $line"
    done
    
    # Try to test read access
    log_info "Teste Lesezugriff auf $COMPORT..."
    if timeout 1 cat "$COMPORT" > /dev/null 2>&1; then
        log_info "Lesezugriff möglich"
    else
        log_info "Lesezugriff-Test beendet (normal bei seriellen Ports)"
    fi
    
    # Try to test write access
    log_info "Teste Schreibzugriff auf $COMPORT..."
    if echo -n "" > "$COMPORT" 2>&1; then
        log_info "Schreibzugriff möglich"
    else
        log_error "Schreibzugriff NICHT möglich!"
    fi
    
    # Try to open with stty to configure
    log_info "Konfiguriere seriellen Port mit stty..."
    if stty -F "$COMPORT" 9600 cs8 -cstopb -parenb 2>&1; then
        log_info "stty Konfiguration erfolgreich"
    else
        log_error "stty Konfiguration fehlgeschlagen"
    fi
fi

log_info "=========================================="
log_info "Starte Busconnectorn4hSvc /data/n4hSvc.cfg"
log_info "=========================================="

# Change to data directory where config file is
cd /data

# Start n4hSvc in background - the binary expects the config file path as first argument
log_info "Starte n4hSvc im Hintergrund..."

# Start n4hSvc and redirect output to log file
/usr/bin/n4hSvc /data/n4hSvc.cfg > /tmp/n4hSvc.log 2>&1 &
N4HSVC_PID=$!

# Wait a moment to check if process crashed immediately
sleep 1

# Check if n4hSvc is still running
if [ -z "$N4HSVC_PID" ] || ! kill -0 "$N4HSVC_PID" 2>/dev/null; then
    log_error "n4hSvc ist sofort nach dem Start beendet!"
    if [ -f /tmp/n4hSvc.log ]; then
        log_error "Letzte Ausgabe von n4hSvc:"
        tail -n 20 /tmp/n4hSvc.log | while IFS= read -r line || [ -n "$line" ]; do
            log_error "  $line"
        done
    fi
    log_error "Versuche mit n4hSvc.cfg..."
    /usr/bin/n4hSvc n4hSvc.cfg > /tmp/n4hSvc.log 2>&1 &
    N4HSVC_PID=$!
    sleep 1
    if [ -z "$N4HSVC_PID" ] || ! kill -0 "$N4HSVC_PID" 2>/dev/null; then
        log_error "Auch mit relativem Pfad fehlgeschlagen!"
        if [ -f /tmp/n4hSvc.log ]; then
            log_error "Letzte Ausgabe:"
            tail -n 20 /tmp/n4hSvc.log | while IFS= read -r line || [ -n "$line" ]; do
                log_error "  $line"
            done
        fi
        log_error "Versuche ohne Argumente..."
        /usr/bin/n4hSvc > /tmp/n4hSvc.log 2>&1 &
        N4HSVC_PID=$!
        sleep 1
        if [ -z "$N4HSVC_PID" ] || ! kill -0 "$N4HSVC_PID" 2>/dev/null; then
            log_error "Alle Startversuche von n4hSvc fehlgeschlagen!"
            if [ -f /tmp/n4hSvc.log ]; then
                log_error "Letzte Ausgabe:"
                cat /tmp/n4hSvc.log | while IFS= read -r line || [ -n "$line" ]; do
                    log_error "  $line"
                done
            fi
            exit 1
        fi
    fi
fi

# Start log forwarder for n4hSvc
(
    tail -f /tmp/n4hSvc.log 2>/dev/null | while IFS= read -r line || [ -n "$line" ]; do
        log_info "[n4hSvc] $line"
    done
) &

log_info "n4hSvc gestartet (PID: $N4HSVC_PID)"

# Wait a moment for n4hSvc to fully initialize
log_info "Warte auf Initialisierung von n4hSvc..."
sleep 2

# Check again if process is still running after initialization
if ! kill -0 "$N4HSVC_PID" 2>/dev/null; then
    log_error "n4hSvc ist nach der Initialisierung beendet!"
    if [ -f /tmp/n4hSvc.log ]; then
        log_error "Letzte Ausgabe:"
        tail -n 30 /tmp/n4hSvc.log | while IFS= read -r line || [ -n "$line" ]; do
            log_error "  $line"
        done
    fi
    exit 1
fi

# Start HSTime if enabled
HSTIME_PID=""
if [ "$ENABLE_HSTIME" = "true" ]; then
    log_info "=========================================="
    log_info "Starte Zeitmodul (HS-Time)..."
    log_info "=========================================="
    
    # Check if HSTime binary exists
    if [ ! -f /usr/bin/HSTime ]; then
        log_error "FEHLER: /usr/bin/HSTime nicht gefunden!"
    else
        log_info "Prüfe Binary /usr/bin/HSTime..."
        log_info "Datei existiert: $(test -f /usr/bin/HSTime && echo 'JA' || echo 'NEIN')"
        log_info "Ausführbar: $(test -x /usr/bin/HSTime && echo 'JA' || echo 'NEIN')"
        
        # Start HSTime in background from persistent directory and suppress all output
        log_info "Starte HSTime im Hintergrund (Arbeitsverzeichnis: /data)..."
        cd /data && /usr/bin/HSTime > /dev/null 2>&1 </dev/null &
        HSTIME_PID=$!
        
        if [ -n "$HSTIME_PID" ] && kill -0 "$HSTIME_PID" 2>/dev/null; then
            log_info "HSTime gestartet (PID: $HSTIME_PID)"
        else
            log_error "FEHLER: HSTime konnte nicht gestartet werden!"
            HSTIME_PID=""
        fi
    fi
else
    log_info "Zeitmodul (HS-Time) ist deaktiviert"
fi

# Start HS-PacketRouter if enabled (after HSTime)
HSPR_PID=""
if [ "$ENABLE_HS_PACKET_ROUTER" = "true" ]; then
    log_info "=========================================="
    log_info "Starte Packetrouter (HS-PacketRouter)..."
    log_info "=========================================="
    
    # Check if HSpr binary exists
    if [ ! -f /usr/bin/HSpr ]; then
        log_error "FEHLER: /usr/bin/HSpr nicht gefunden!"
    else
        log_info "Prüfe Binary /usr/bin/HSpr..."
        log_info "Datei existiert: $(test -f /usr/bin/HSpr && echo 'JA' || echo 'NEIN')"
        log_info "Ausführbar: $(test -x /usr/bin/HSpr && echo 'JA' || echo 'NEIN')"
        
        # Start HSpr in background from persistent directory and suppress all output
        log_info "Starte HSpr im Hintergrund (Arbeitsverzeichnis: /data)..."
        cd /data && /usr/bin/HSpr > /dev/null 2>&1 </dev/null &
        HSPR_PID=$!
        
        if [ -n "$HSPR_PID" ] && kill -0 "$HSPR_PID" 2>/dev/null; then
            log_info "HSpr gestartet (PID: $HSPR_PID)"
        else
            log_error "FEHLER: HSpr konnte nicht gestartet werden!"
            HSPR_PID=""
        fi
    fi
else
    log_info "Packetrouter (HS-PacketRouter) ist deaktiviert"
fi

# Monitor all processes
log_info "=========================================="
log_info "Services laufen, überwache Prozesse..."
log_info "=========================================="

# Function to check if processes are still running
check_processes() {
    if [ -n "$N4HSVC_PID" ] && ! kill -0 "$N4HSVC_PID" 2>/dev/null; then
        log_error "n4hSvc Prozess (PID: $N4HSVC_PID) ist beendet!"
        return 1
    fi
    if [ -n "$HSTIME_PID" ] && ! kill -0 "$HSTIME_PID" 2>/dev/null; then
        log_error "HSTime Prozess (PID: $HSTIME_PID) ist beendet!"
        return 1
    fi
    if [ -n "$HSPR_PID" ] && ! kill -0 "$HSPR_PID" 2>/dev/null; then
        log_error "HSpr Prozess (PID: $HSPR_PID) ist beendet!"
        return 1
    fi
    return 0
}

# Wait for processes and monitor them
while true; do
    if ! check_processes; then
        log_error "Ein Service ist beendet, beende Container..."
        exit 1
    fi
    sleep 5
done
